% !TeX spellcheck = fa
\documentclass[a4paper,12pt]{report}

\usepackage{color}
\usepackage{xcolor}
\usepackage{fourier}
\usepackage{amsmath}
\usepackage{dirtree}
\usepackage{caption}
\usepackage{verbatim}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{outlines}
\usepackage{enumitem}
\usepackage{fancyvrb}
\usepackage{subcaption}
\usepackage[Bjornstrup]{fncychap}%Options: Sonny, Lenny, Glenn, Conny, Rejne, Bjarne, Bjornstrup
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage[colorlinks,linkcolor=blue,citecolor=red,urlcolor=blue]{hyperref}
\usepackage[logo=on,fontsize={12,18}]{xepersian}

%\settextfont{Microsoft Sans Serif}
\settextfont{XB Yas}
\setlatintextfont{Arial}

\definecolor{ao}{rgb}{0.0, 0.5, 0.0}
\definecolor{codeGreen}{rgb}{0, 0.5, 0.5}
\definecolor{lavendergray}{rgb}{0.87, 0.86, 0.92}
\definecolor{mint}{rgb}{0.24, 0.71, 0.54}
\definecolor{aliceblue}{rgb}{0.94, 0.97, 1.0}
\definecolor{customCommentGreen}{rgb}{0.13, 0.65, 0.47}
\definecolor{steelBlue}{rgb}{0.00, 0.00, 0.50}
\definecolor{stringGreen}{rgb}{0, 0.5, 0}

\pagestyle{fancy}

\cfoot{\thepage}
%\rhead{\thepage }

\renewcommand{\headrulewidth}{0.4pt}

\newcommand{\lrInlineMono}[1]{{\color{steelBlue}\lr{\texttt{#1}}}}

\begin{document}
	\lstset{
		frame=tb,
		basicstyle=\color{steelBlue}\linespread{0.8}\ttfamily,
		columns=fullflexible,
		keepspaces=false,
		tabsize=3,
		autogobble,
		breaklines=true,
		breakatwhitespace=true,
		stringstyle=\color{stringGreen},
		commentstyle=\color{gray},
		keywordstyle=\color{purple},
		language=C++,
		aboveskip=3mm,
		belowskip=3mm,
		showstringspaces=false,
		columns=flexible,
		captionpos=b,
		numbers=left,
		numbersep=5pt,
		numberstyle=\color{gray}\linespread{0.8}\ttfamily,
		postbreak=\mbox{\textcolor{blue}{$\hookrightarrow$}\space}
	}
	
	\renewcommand{\bibname}{مراجع}
	
	\title{
		\setlatintextfont{XB Titre}
		\lr{Portability and Safety: Java}
	}
	\author{
		سیّد مُرتِضیٰ رَضوی
	}
	\date{
		پنج‌شنبه، ۱۴ فروردین ۱۳۹۹
	}
	
	\maketitle
	\setcounter{page}{384}
	
	\setcounter{chapter}{12}
	\chapter{امنیت و قابلیت‌حمل: جاوا}\label{chap13}
	زبان برنامه‌نویسی جاوا
	\LTRfootnote{\lr{Java.}}
	 توسط آقای جیمز گاسلینگ 
	\footnote{\lr{James Gosling}
		همچنین به عنوان
	\lr{Dr.java}
		شناخته می‌شوند.}
	و چند تن دیگر در شرکت 
	\lr{Sun Microsystems}
	\footnote{شرکت سان میکرو سیستم سازنده رایانه و نرم‌افزار است.}
	طراحی شد.
	این زبان از یک پروژه در سال ۱۹۹۰ بوجود آمد که 
	Oak \footnote{\lr{/əʊk/}
	به معنی بلوط.}
	 نام داشت و بر روی دستگاه‌هایی مورد استفاده قرار گرفت که به عنوان 
	\lr{set-top box}
	 نیز شناخته می‌شدند.
	 
	\lr{set-top box}
	 دستگاه کوچک محاسباتی که به یک شبکه متوسط متصل شده و در بالای یک تلویزیون قرار می‌گیرد. این دستگاه ويژگی‌های زیادی فراهم می‌کند. شما می‌توانید تصور کنید با این فرض که یک مرورگر وب بر روی تلویزیون شما به نمایش درآمده و به جای استفاده از صفحه کلید،شما ‌با استفاده از یک کنترل بر روی آیکون‌های آن کلیک می‌کنید. 
	 ممکن است  شما بخواهید یک برنامه یا فیلم را انتخاب کنید و یا اینکه یک برنامه شبیه ساز کامپیوتر را که توانایی اجرا بر روی یک دستگاه محاسباتی را داشته باشد دانلود و اجرا کنید و آن را به نمایش درآورید. 
	 یا حتی یک تبلیغات تلویزیونی در مورد ماشین می‌تواند با ایجاد یک شبیه سازی منحصر   به فرد رانندگی آن ماشین در جاده در قالب یک تور برای هر بیننده ایجاد کند.
	 هرچند که این سناریو می‌تواند برای شما جذاب باشد، محیط گرافیکی می‌تواند شامل گرافیک، اجرای برنامه‌های ساده و ایجاد ارتباط بین یک سایت و یک برنامه که به صورت داخلی اجرا می‌شود، باشد.
	 
	 در نقطه از توسعه Oak ،مهندسین و مدیران در شرکت سان میکرو سیستم متوجه یک نیاز فوری برای ایجاد یک زبان برنامه نویسی تحت مرورگر  شدند، 
	 یک زبان که می‌توانست برای نوشتن برنامه‌های کوچکی که تحت شبکه متنقل می‌شدند و بر روی هر مرورگر استاندارد در یک پلتفرم استاندارد اجرا می‌شدند استفاده شود.
	و از طرفی نیاز برای استاندارد به دلیل خواسته ذاتی اشخاص و کمپانی‌ها برای داشتن بیشترین مخاطب ممکن بود. علاوه بر قابل حمل بودن، همچنین نیاز به امنیت هم وجود داشت بنابراین کسی که برنامه‌ی کوچکی را دانلود می‌کرد، قادر به اجرای آن بدون ترس از ویروس کامپیوتری یا خطرات دیگر بود.
	
	زبان برنامه نویسی
	\lr{Oak}
  با هدف پیاده سازی دوباره زبان برنامه‌نویسی 
	\lr{C++}
  شروع شد. درحالی که، این طراحی زبان هدف انتهایی پروژه نبود، بلکه تبدیل به تمرکز گروه بر روی آن شد.
  برخی دلایل طراحی یک زبان جدید در این کتاب بیش از حد نمایشی هستند، اما هنوز برخی نقل قول‌های آموزنده از "
	\lr{The Java Saga}"
  توسط دیوید بلانک در 
	\lr{Hot Wierd}\footnote{
  سایت
	\lr{http://www.hotwired.com/}}
	(در دسامبر ۱۹۹۵) موجود است:
	
	\begin{center}
		\fcolorbox{ao}{aliceblue}{%
		\begin{minipage}{.9\linewidth}
			
			%Figure james gsaling
			
			\noindent\textbf{
			جیمز گاسلینگ }
			\\[5mm]		
		جیمز گاسلینگ مهندس ارشد و طراحی کلیدی زبان برنامه نویسی و پلتفرم جاوا بود. او هم‌اکنون در مرکز 
		تحقیقات شرکت سان بر روی ابزار‌های توسعه نرم افزار فعالیت می‌کند. اولین پروژه وی در شرکت سان،  سیستم
		پنجره 
	\lr{NeWS}\footnote{مخفف \lr{Network extensible Window System}.}
		بود که برای 
		\lr{Sun workstation}\footnote{\lr{/sʌn ˈwɝːkˌsteɪʃən/}
		به معنی ایستگاه کاری سان.} در سال ۱۹۸۰ توزیع شده بود.
		قبل از پیوستن وی به شرکت سان، گاسلینگ، یک نسخه چند پردازنده از یونیکس 
		\LTRfootnote{\lr{UNIX /ˈjuːnɪks/.}}
		 ساخت، همچنین سیستم پنجره اندرو
		\LTRfootnote{\lr{Andrew.}}
		به همراه ابزار آن 	 و خیلی از کامپایلر‌ها و سیستم‌های 
		\lr{mail}.
		همچنین او در نظر افراد زیادی سازنده ویرایشگر
		 \lr{Emacs}
		  است.
		
		تکنیکی با حس شوخ طبعی، گاسلینک در تصویر سمت راست در حال زدن یک کیک به صورت یک بازیگر با ماسک بیل گیتس است، عکسی که در صفحه سایت خود در 
		\lr{http://java.sun.com/people/jag/}
		 که تا حدی سیاسی شده‌است قرار دارد.
		
		جیمز گاسلینک مدرک ارشد خود را در رشته کامپیوتر از دانشگاه کلگری 
		\LTRfootnote{\lr{Calgary, Canada.}}
		در کانادا دریافت کرد، او همچنین مدرک دکترای خود را از دانشگاه ملون و با پایان نامه‌ای در عنوان "دستکاری جبری محدودیت‌ها"
		\LTRfootnote{\lr{The Algebraic Manipulation of Constraints.}}
		 دریافت کرد.
		
		\end{minipage}}%
	
		\begin{minipage}{0.9\linewidth}
	گاسلین به سرعت متوجه شد که زبان‌های موجود کارایی مورد نیاز را برای کاری که در سر داشت، ندارند. از جهتی زبان
	\lr{C++}
	برای برنامه نویسان برنامه‌های تخصصی تقریباً یک زبان نزدیک به استاندارد تبدیل شده بود، جایی که سرعت همه چیز بود. اما 
	\lr{C++}
	برای چیزی که گاسلینگ در سر داشت به حد کافی قابل اطمینان نبود. آن سریع بود، اما رابط‌های آن
	ناسازگار بودند، و برنامه‌های با خطا موجه می‌شدند. درحالی که برای مصرف کنندگان وسایل الکتریکی قابلیت اطمینان از سرعت مهم‌تر است.
	رابط‌های نرم‌افزاری باید به اندازه یک دوشاخه که مناسب پریز برق است، قابل اطمینان باشند. و اینطور شد که گاسلینگ گفت "من به این نتیجه رسیدم که به زبان برنامه‌نویسی جدید نیاز دارم".

		\end{minipage}
	\end{center}

	برای دلایل متنوعی ازجمله تلاش عظیم سان میکرو سیستم، ‌جاوا بعد از انتشار آن به عنوان زبان ارتباط اینترنت در میانه سال ۱۹۹۵ به طور شگفت‌آوری موفق شد.
	
	قسمت‌های اصلی جاوا عبارت‌اند از:
	
	\begin{itemize}
		\renewcommand{\labelitemi}{\color{gray}\scriptsize$\blacksquare$}
		\item 
		زبان برنامه‌نویسی جاوا.
		\item
			کامپایلر و سیستم‌های زمان اجرا (ماشین مجازی جاوا)
		\item
		کتابخانه گسترده، شامل جعبه ابزار جاوا برای نمایش‌های گرافیکی و کاربرد‌های دیگر و نمونه‌های برنامه‌های کوچک جاوا.
	\end{itemize}

		اگرچه کتابخانه و مجموعه ابزارها به دسترسی سریع‌تر کمک کردند،‌ اما ما در درجه اول به زبان برنامه نویسی، پیاده سازی آن و نحوه تاثیر گذاری طراحی زبان و پیاده سازی آن علاقه‌مند شدیم.
	گاسلینگ،‌ در زندگی عادی فروتن تر از آن چیزی است که در نقل قول قبلی نشان می‌دهد است، او درمورد زبان‌هایی که بر روی جاوا تاثیر گذار بودند چنین می‌گوید: " یکی از مهم‌ترین زبان‌های تاثیر گذار بر روی طراحی جاوا زبانی ابتدایی به نام 
	\textit{\lr{Simula}}
	بود. آن اولین زبان شئ‌گرا بود که من استفاده کردم (بر روی یک 
	\lr{CDC 6400}!
	)... جایی که مفهوم 'کلاس' ابداع شده بود".
	
	\section{پیشگفتاری بر زبان جاوا}\label{sec1:chap13}
	\subsection{اهداف زبان جاوا}\label{subsec1:sec1:chap13}
	
	زبان برنامه‌نویسی جاوا و محیط اجرایی آن با اهداف زیر طراحی شدند.
	
	\begin{itemize}[nosep]
		\renewcommand{\labelitemi}{\color{gray}\scriptsize$\blacksquare$}
		\item 
		\textit{
		قابلیت حمل}: برنامه‌ها باید به آسانی بر روی شبکه انتقال پیدا کنند و به درستی بر روی محیط دریافت کننده اجرا شوند، بدون در نظر گرفتن سخت‌افزار، سیستم عامل یا حتی مرورگر مورد استفاده.
		\item
		\textit{
		قابلیت اطمینان}: به دلیل اینکه برنامه‌ها توسط افرادی از راه دور اجرا می‌شوند که کد را ننوشته‌اند، باید در حد امکان از پیام‌های خطا و قفل شدن برنامه‌ها جلوگیری کرد.
		\item \textit{
		امنیت}: محیط محاسباتی که برنامه را دریافت می‌کند باید نسبت به خطا‌های برنامه‌نویسان و همچنین برنامه‌نویسان مخرب محافظت شده باشد.
		\item \textit{
		لینک شدن پویا}: برنامه‌ها در بخش‌های مختلفی توزیع شده‌اند، و هر بخش به صورت جدا و در زمان مورد نیاز در محیط اجرایی جاوا اجرا می‌شود.
		\item \textit{
		اجرای چندنخی}: برای اینکه همزمانی برنامه‌ها بر روی سخت افزار‌های متنوع اجرا شوند، زبان باید دارای پشتیبانی صریح و رابط استاندارد برای این عمل  باشد.
		\item \textit{
		سادگی و آشنایی}: زبان باید برای یک برنامه نویس متوسط وب جذابیت داشته باشد، معمولاً یک برنامه‌نویس زبان C یا یک برنامه نویس که حدوداً با 
		\lr{C/C++}
		آشناست.
		\item \textit{
		بازدهی}: این امر مهم است، ولی ممکن است جزء ملاحظات ثانویه قرار گیرد.
	\end{itemize}
	
	درحالت کلی، تمرکز کمتر بر روی بازدهی زبان انعطاف بیشتری را برای برنامه‌نویسان جاوا نسبت به 
	\lr{C++}
	ایجاد کرد.	
	
	\subsection{تصمیمات طراحی}\label{subsec2:sec1:chap13}
	برخی از اهداف طراحی و تصمیمات طراحی کلی در 
	\hyperref[table1:chap13]{جدول ۱۳.۱}
	 قرار دارند، که در آن علامت + به معنی این است که آن تصمیم منجر به تاثیر مثبت در آن هدف، علامت - به معنی تاثیر منفی در آن هدف، و +/-	نشان دهنده این است که برخی معایب و برخی مزایا در این تصمیم وجود دارد. همچنین برخی خانه‌ها خالی مانده‌اند، که نشان دهنده بی تاثیر یا کم تاثیر بودن آن تصمیم در آن هدف است. به راحتی می‌توانیم اهمیت بازدهی در فرایند طراحی جاوا را با نگاه کردن به  راست‌ترین ستون متوجه شویم. اما این بدین معنی نیست که بازدهی کاملاً بی‌نیاز قربانی شده باشد، و فقط نسبت به دیگر اهداف در اولویت اول قرار نداشت.
	
	\begin{table}[h!t!]
		\begin{center}
			\captionsetup{justification=raggedleft,singlelinecheck=off}
			\caption{تصمیمات طراحی جاوا}
			\label{table1:chap13}
			\begin{tabular}{rrrrr}
				&قابلت حمل&امنیت&سادگی&بازدهی\\
				\hline
				مفسری بودن&+&+&&-\\
				نوع ایمنی&+&+&+/-&+/-\\
				بیشتر مقادیر شئ هستند&+/-&+/-&+&-\\
				اشیاء اشاره‌گر هستند&+&&+&-\\
				زباله روب&+&+&+&-\\
				پشتیبانی از همزمانی&+&+&&\\
				\hline
			\end{tabular}
		\end{center}
	\end{table}

	\textbf{\textit{
	مفسری بودن}}. شروع و بیشتر پیاده‌سازی جاوا بر پایه تفسیر بایت ‌کد
	\LTRfootnote{\lr{byte code.}}
 است. که در 
	\hyperref[chap13]{
		بخش ۱۳.۴}	بیشتر در این مورد بحث شده است. به طور خلاصه برنامه‌های جاوا ابتدا به یک زبان ساده و سطح پایین کامپایل می‌شوند. این زبان، بایت کد نام دارد،‌ به این دلیل که معمولاً زمانی مورد استفاده قرار می‌گیرد که برنامه‌های جاوا در بستر شبکه به عنوان قسمتی از صفحه وب ارسال می‌شوند. بایت‌کد‌های جاوا توسط یک مفسر به نام ماشین مجازی جاوا (JVM)
	\LTRfootnote{\lr{Java virtual machine , /ˈdʒɑːvə ˈvəːtʃʊ(ə)l məˈʃiːn/.}}
	 اجرا می‌شوند. یکی از مزایای این معماری این است که هنگامی که 
	 \lr{JVM}
	 برای یک سخت افزار و سیستم عامل خاص پیاده سازی می‌شود، تمام برنامه‌های جاوا می‌توانند بدون تغییر در کد در آن اجرا شوند. علاوه بر قابلیت حمل، تفسیر شدن این بایت‌کد‌ها به اجرای ایمن کمک می‌کنند،‌ و درست زمانی فرمانی نقض شود تشخیص‌گر معنایی زبان جاوا قبل از اجرا آن را تشخصی می‌دهد. برای یک مثال خوب می‌توان به چک شدن حدود آرایه اشاره کرد. چون تشخیص اینکه یک برنامه به خارج از مرز آرایه دسترسی دارد در زمان کامپایل ممکن نیست. اما، 
	 \lr{JVM}
	 تست‌های زمان اجرایی دارد تا مطمعن شود هیچ برنامه‌ای به خارج از مرز آرایه خود دسترسی ندارد.

	\textbf{\textit{
	نوع ایمنی}}. سه سطح از نوع ایمنی در جاوا وجود دارد. اولین آن چک کردن سورس کد جاوا در زمان کامپایل است. تشخیص نوع جاوا مانند خیلی از تشخیص نوع‌های مرسوم عمل می‌کند ( همانند پاسکال
	\footnote{یک زبان برنامه نویسی کامپایلری.}
	، \lr{C++}
	و غیره)، که از کامپایل برنامه‌هایی که از رویه زبان جاوا پیروی نمی‌کنند جلوگیری می‌کند.
	هیچ عملیات ریاضی بر روی اشاره‌گرها وجود ندارد، هیچ نوع تبدیل صریحی وجود ندارد و زبان زباله روبی می‌شود،برای مثال اثبات شده است که یک درجه از امنیت نوع بیشتر نسبت به 
	\lr{C++}
	را دارد. و سطح دوم از امنیت نوع، چک کردن نوع قبل از زمانی است که برنامه‌های بایت‌کد جاوا اجرا می‌شوند. و سطح سوم چک کردن نوع در زمان اجرا است، مانند چک کردن حدود آرایه که در زیر بخش قبل توضیح داده شد. به علاوه بر امنیت، سیستم نوع جاوا برخی از ساختار‌هایی را که ممکن است سیستم معنایی و یا اجرایی زبان را پیچیده کنند، ساده سازی و حذف می‌کند.
	
	\textbf{\textit{
	اشیاء و ارجاعات
	\LTRfootnote{\lr{References.}}
}}. در جاوا حدوداً همه چیز شئ هستند، ولی نه همه چیز. به صورت خاص، برخی از انواع معین و پایه مثل اعداد صحیح
	\LTRfootnote{\lr{Integer.}}
، نوع بولین
	\LTRfootnote{\lr{Boolean.}}
 و رشته‌ها شئ نیستند. این مقایسه بین سادگی و کارایی است. در بیان جزئی تر، اگر تمامی عملیات مربوط به اعداد صحیح نیازمند مراجعه پویا به حافظه باشند، به طور قابل ملاحظه‌ای باعث کند شدن محاسبات در اعداد صحیح می‌شود. یک تصمیم ساده در مورد اشیاء باعث شد که تمامی آنها از طریق اشاره‌گر در دسترس باشند و انتصاب با استفاده از اشاره‌گر تنها نوع انتصابی است که برای تمام اشیاء فراهم دیده شده. این امر باعث سادگی برنامه‌ها در مسائل خاص شده است، اما در برخی شرایط کارایی برنامه را کاهش می‌دهد.

تمامی پارامترها در متدهای جاوا با استفاده از مقدار فرستاده می‌شوند. زمانی که یک پارامتر یک نوع ارجاعی دارد (شامل تمامی اشیاء و آرایه‌ها)، اگرچه خودش یک نوع ارجاع است، اما کپی شده و با مقدار فرستاده می‌شود. در واقع، این یعنی که مقادیر نوع‌های اولیه با مقدار و اشیاء با ارجاع ارسال می‌شوند.
	
	
	\textbf{\textit{
	زباله روب}}. همانطور که در 
	\hyperref[subsec1:sec2:chap6]{
	زیر بخش ۶.۲.۱} بحث شد، زباله روب برای کامل کردن ایمنی نوع  نیاز است. زباله روب همچنین باعث ساده شدن برنامه نویسی می‌شود، که با حذف آن قسمت از کد که باید تشخیص داده شود که چه لحظه‌ای باید بازپس گیری حافظه انجام شود، اما باعث کندی اجرا می‌شود. 
	زباله روب جاوا از مزایای همزمانی در برنامه استفاده می‌کند،‌به این حالت که در پس زمینه اجرای برنامه و به صورت یک رشته با اولویت پایین پیاده سازی شده است، که این اجازه را به زباله روب می‌دهد تا زمانی اتفاق بیافتد که کاربر متوجه افت سرعت نشود.
	
	\textbf{\textit{
	پیوند پویا}}. 
	کلاس‌هایی که در جاوا تعریف و استفاده شده‌اند ممکن است به صورت مکرر در 
	\lr{JVM}
	بارگزاری شوند،‌ درست زمانی که آنها مورد نیاز برنامه اجرایی باشند. این کار زمان سپری شده بین شروع انتقال برنامه بر بستر شبکه و زمان شروع اجرای آن را کوتاه کند،‌ درحالی که برنامه درست قبل از اینکه تمام کد منتقل شود می‌تواند اجرا شود. علاوه براین درصورتی که برنامه‌ای بدون اینکه به کلای نیاز داشته باشد خاتمه یابد در اینصورت آن کلاس در JVM بارگزاری و حتی انتقال داده نمی‌شود. پیوند پویا تاثیر چندانی بر روی طراحی زبان ندارد، غیر از نیاز برای رابط‌های شفاف که بتوانند قسمت‌هایی از یک برنامه را تحت برخی فرضیات نسبت به قسمتی از کد فراهم شده در بخش دیگر برنامه چک کنند.
	
	
	\textbf{\textit{
	پشتیبانی از همزمانی}}. جاوا یک مدل همزمانی بر پایه رشته‌ها
	\LTRfootnote{threads.}
 دارد، که به فرایندهای همزمان وابسته است. این یک قسمت مهم از زبان است، به دو دلیل طراحی اساسی و اهمیت داشتن اصول همزمانی استاندارد به عنوان قسمتی از زبان جاوا است. به طور واضح اگر همزممانی جاوا وابسته به مکانیسم وابسته به سیستم عامل بود، به هیچ عنوان نمی‌توانست بین دستگاه‌های دیگر قابلیت حمل داشته باشد.
 
	 \textbf{\textit{
	 سادگی}}. اگرچه جاوا در طی سال‌ها رشد کرده و ویژگی‌هایی مانند کلاس‌های داخلی و بازتاب به نظر ساده نیستند، اما این زبان هنوز هم خیلی ساده‌تر و کوچک‌تر از دیگر زبان‌های همه منظوره و برپایه کیفیت تولید است. یکی از راه‌هایی که که متوجه بشید زبان جاوا ساده است این است که لیست ویژگی‌هایی از 
 	\lr{C++}
 	را که در جاوا وجود ندارند را ببینید. که این شامل ویژگی‌های زیر می‌شود:
 	
	\begin{itemize}[nosep]
 		\renewcommand{\labelitemi}{\color{gray}\scriptsize$\blacksquare$}
 		\item 
 		\textit{
 		ساختار‌ها و اتحادها}: ساختارها در رده اشیاء قرار می‌گیرند،‌و برخی از کاربرد‌های اتحادها را می‌توان
 	 با کلاس‌هایی که از یک کلاس ارث‌بری شده‌اند جایگزین کرد.
 	
	 	\item 
	 	\textit{
	 	توابع} را می‌توان با متد‌های ایستا جایگزین کرد.
	 	\item 
	 	\textit{
	 	ارث‌بری چندگانه} پیچیده است و در بیشتر مواقع اگر یک مفهوم رابط سادهتر از جاوا استفاده شود میتوان از آنها پرهیز کرد.
	 	\item 
	 	\textit{
	 	\lr{Goto}}
 		ضروری نیست.
	 	\item 
	 	\textit{
	 	سربارگذاری عملگر‌های پیچیده است و غیر ضروری تلقی می‌شود}، توابع جاوا می‌توانند سربارگذاری شوند.
	 	\item 
	 	\textit{
	 	تبدیل‌های خودکار} پیچیده هستند و غیر ضروری تلقی می‌شوند.
	 	\item 
	 	\textit{
	 	اشاره‌گرها} به طور پیشفرض برای اشیاء وجود دارند و برای بقیه نوع‌ها نیاز نیستند، پس در نتیجه یک نوع اشاره‌گری جدا نیاز نیست.
 	\end{itemize}
 	
 	برخی از این ویژگیها که در 
 	\lr{C++}
 	موجود هستند به دلیل سازگاری رو به عقب با C  است. و بقیه به دلایل برخی تصمیمات از جاوا حذف شده اند، به این دلیل که آنها تصمیم گرفتند که پیچیدگی اضافه‌کردن آن ویژگی‌ها خیلی بیشتر از عملکرد آنها مورد توجه است. و قابل توجه ترین حذف ویژگی مربوط به ارث‌‌بری چندگانه،  تبدیل‌های خودکار، سربارگذاری عملگر‌ها و عملیات اشاره‌گر در 
 	\lr{C} و \lr{C++}
 	هستند.
 	
 	\section{
 	کلاس‌های جاوا و ارث‌بری}
 	\label{sec2:chap13}
 	\subsection{
 	کلاس‌ها و اشیاء
 	}\label{subsec1:sec2:chap13}
 			
 	جاوا در به نحو 
 	\lr{C++}
 	نوشته شده است،‌پس در نتیجه برنامه‌نویسی آن هم به برنامه نویسان 
 	\lr{C} و \lr{C++}
 	نزدیک تر است. این باعث می‌شود که کد نقطه یک بعدی که در 
 	\hyperref[subsec1:sec3:chap12]{
	زیربخش ۱۲.۳.۱} آمده است، به کدی که به جاوا تبدیل شده است خیلی شبیه‌تر باشد. که در اینجا یک ورژن خلاصه شده از کلاس با حذف متد 
 	\lr{move} 
 	را داریم:
 		
	\begin{latin}
		\small
		\begin{lstlisting}[]
class Point {
	public int getX() { ...}
	protected void setX (int x) { ...}
	private int x;
	Point(int xval) {x = xval;}
};		
		\end{lstlisting}
	\end{latin}	
			
	مانند خیلی از زبان‌های دیگر کلاس محور، جاوا هم داده‌ها و توابع را با تمام شئ‌هایی که توسط این کلاس ساخه می‌شوند مرتبط می‌کند. و زمانی که یک شئ ایجاد می‌شود فضای داده‌های آن اختصاص داده شده و سازنده برای مقدار دهی اولیه مقادیر فراخوانی می‌شود. مانند 
	\lr{C++}
	سازنده نامی برابر با نام  کلاس دارد. و همچنین مانند 
	\lr{C++}
	اجزاء در کلاس point ‌دسترسی‌های
	\lr{public}، \lr{private} و \lr{protected}
	 را دارند.
	  همچنین
	\lr{public}، \lr{private} و \lr{protected}
		کلمات کلیدی جاوا هستند، و همانطور که در 
	\linebreak\hyperref[subsec2:sec2:chap13]{زیربخش ۱۳.۲.۲} 
اشاره شده،‌این خصوصیات دسترسی به معنی شبیه بودن این دو زبان نیست.

	واژه شناسی جاوا اندکی با
	\lr{Simula}، \lr{Smalltalk} و \lr{C++}
	متفاوت است، که در اینجا یک خلاصه کوتاه از مهم‌ترین واژه‌های استفاده شده در توصیف جاوا را بررسی می‌کنیم:
	
	
	\begin{itemize}
		\renewcommand{\labelitemi}{\color{gray}\scriptsize$\blacksquare$}
		\item \textit{
		کلاس} و \textit{شئ}، اساساً همانند دیگر زبان‌های برپایه کلاس و شئ‌گرا به یک معنی هستند.
		
		\item \textit{
		فیلد}،
		\LTRfootnote{field.}
		:داده عضو،
		\textit{
		متد
		\LTRfootnote{Method.}
		}: توابع عضو، 
		\textit{
		عضو ایستا
		\LTRfootnote{static member.}}
		: مشابه به فیلد کلاس و یا متد کلاس در Smalltalk ،
		\textit{
		this \footnote{
		اشاره‌گری به شئ جاری}}: مانند 
		\lrInlineMono{this} در  \lr{C++}
		و یا 
		\lrInlineMono{self} در \lr{Smalltalk} 
		مشخصه
		 \lrInlineMono{this}
		  در بدنه متد‌های جاوابه معنی شئ است که این متد را فراخوانی کرده است.
		\item \textit{
		متدهای بومی}: متدهایی که در زبان دیگری نوشته می‌شوند، مانند C
		\item \textit{
		پکیج‌}: یک مجموعه از کلاس‌ها که یک فضای نام را به اشتراک می‌گذارند.
	\end{itemize}

	ما خیلی از مشخصات کلاس‌ها در جاوا را شامل فیلد‌ها و متدهای ایستا،  سربار گذاری، متد‌های پایانی، متد main ، متد toString که برای چاپ یک نما از شئ یه و همچنین امکان استفاده از کد‌های بومی را مشاهده کردیم. ما در ادامه بحث‌هایی حول زمان اجرای جاوا از اشیاء و پیاده‌سازی متد lookup در 
	\hyperref[sec4:chap13]{
	بخش ۱۳.۴} که در رابطه با ایجاد یک ارتبطا به جنبه‌های دیگر ساختار زمان اجرای سیستم است، خواهیم داشت.

	\textbf{\textit{
	مقدار دهی اولیه}}. جاوا تضمین می‌کند، زمانی که یک شئ ساخته می‌شود یک سازنده‌هم فراخوانی می‌شود.
	و به دلیل اینکه با ارث ‌بری مسائلی ایجاد می‌کند، از قسمت در 
	\hyperref[subsec3:sec2:chap13]{
	زیربخش ۱۳.۲.۳ } مفصل بحث شده است.
	
	\textit{\textbf{
	متد‌ها و فیلد‌های ایستا}}. متد‌ها و فیلد‌های ایستا در جاوا مشابه به متد و فیل در Smalltalk است. اگر یک فیلد به صورت ایستا تعریف شود، درنتیجه آن فیل برای کل کلاس مشترک است و نه برای هر یک شئ و اگر متدی ایستا تعریف شود در نتیجه این متد بدون یک شئ از کلا می‌تواند فراخوانی شود. در حالت کلی، متد‌های ایستا می‌توانند حتی قبل ز اینکه  شئ از کلاس ایجاد شوند، فراخوانی شوند. در نتیجه متد‌های ایستا تنها قابلیت دسترسی به فیلد‌های ایسستا و بقیه متد‌های ایستا را دارند. آنها نمی‌توانند به شئ this ارجاع کنند زیرا هیچ قسمتی از شئ خاصی از کلاس نیستند. در خارج از یک کلاس عضو ایستا با اسم خود کلاس فراخوانی می‌شود که فراخوانی آن به صورت 
	\lrInlineMono{class\_name.static\_method(args)}
	است و نه از طریق یک شئ از کلاس.
	
	فیلد‌های استاتیک می‌توانند با یک عبارت یا یک بلوک مقدار ‌دهی ایستا، مقدار دهی شوند. که هر دو در قطعه کد زیر نمایش داده شده‌اند.
	
	\begin{latin}
		\small
		\begin{lstlisting}[]
class ... {
	/* --- static variable with initial value --- */
	static int x = initial value;
	/* --- static initialization block --- */
	static { /* code to be executed once, when class is loaded */
	}
}
		\end{lstlisting}
	\end{latin}	
	
	همانطور که از کامنت‌های برنامه مشخص است، بلوک مربوط به ایستا در کد فقط یک بار زمانی که کلاس بارگزاری می‌شود اجرا می‌شود. بارگذاری کلاس در 
	\hyperref[sec4:chap13]{
		بخش ۱۳.۴} در اتصال به JVM مفصل بحث شده است. قوانین مختلفی بر برتیب اجرای مقدار دهی‌های ایستا حاکم است. زمانی‌که یک کلاس شامل هر دو مقدار دهی، هم نوع عبارت و هم بلاک ایستا است. حتی محدودیت‌هایی هم بر مقدار دهی ایستا وجود دارد. برای     
	
	
	مثال، یک مقدار‌دهی ایستا نمی‌تواند یک حالت استثنا ایجاد کند، به این دلیل که هیچ اطمینانی وجود ندارد که یک کنترل کننده متناظر در هنگام بارگذاری کلاس برای آن ایجاد شود.
	
	
	\textit{\textbf{
		سربار گذاری}}. سربار گذاری در جاوا برحسب امضاء متد است، که شامل اسم متد، تعداد پارامترها و نوع هر پارامتر ورودی است. و همچنین اگر دوو متد از یک کلاس (چه هردو در یک کلاس اعلان شده باشند یا هر دو ارث‌بری شده باشند و یا یکی ارث‌بری شده و دیگری اعلان شده باشد) اسم یکسان۷ اما امضاء متفاوتی داشته باشند، در نتیجه متد نام آنها سربار گذاری شده است. و همانند دیگر زبان‌ها در زمان کامپایل چک می‌شود.
	
	
	\textit{\textbf{
	زباله روب و نهایی کردن}}. به دلیل اینکه جاوا زباله روبی می‌شود،‌هیچ نیازی بر آزاد سازی صریح اشیاء نیست. به علاوه، برنامه نویسان نیازی به نگرانی در مورد ارجاع‌های زائدی که توسط بازپس ‌گیری حافظه انجام می‌شود ندارند. هرچند زباله روب فقط فضایی که توسط یک شئ ایجاد شده است را باز پس گیری می‌کند. اما اگر شئ دسترسی بر نوع خاصی از منبع را نگه دارد، در نتیجه این منبع باید زمانی که این شئ دیگر در دسترس نیست آزاد شود. به همین دلیل، اشیاء در جاوا، متد
	\lrInlineMono{finilize}
	دارند که بر اساس دو شرط فراخوانی می‌شوند، به وسیله زباله روب، زمانی که فضا بازپس گیری می‌شود و به به وسیله ماشین مجازی، زمانی که ماشین مجازی خاتمه می‌یابد. یکی از عرف‌های مفید متد
	\lrInlineMono{finilize}
	فراخوانی 
	\lrInlineMono{super.finilize}
	است. همناطور که در ادامه نشان می‌دهیم، هر قطعه کد خاتمه‌ای مربوط به کلاس پدر نیز فراخوانی می‌شوند:
	
\begin{latin}
	\small
	\begin{lstlisting}[]
class ... {
	...
	protected void finalize () {
		super.finalize();
		close(file);
	}
};
	\end{lstlisting}
\end{latin}	

	همچنین یک بازخورد جالب بین متد 
	\lrInlineMono{finilize}
	و استثناء‌ها وجود دارد، بدین‌گونه که در صورت رخ‌دادن هر استثناء مدیریت نشده‌ای آن استثناء نادیده گرفته می‌شود.
	
	یک مشکل مرتبط با متد 
	\lrInlineMono{finilize}as
	کنترل نداشتن صریح برنامه‌نویس زمان فراخوانی متد 
	\lrInlineMono{finilize}
	است. 
	که این تصمیم گیری به سیستم زمان اجرا واگذار شده است. و درصورتی که یک شئ یک منبع مشترک را در دسترس داشته باشد مشکل ساز است، برای مثال، چنانچه که قفل دسترسی ممکن است تا زمانی که زباله روب تشخیص ندهد که برنامه به فضای بیشتری نیاز دارد آزاد نشود.
	که یک راه‌حل گذاشتن عملگرهایی از جمله آزاد سازی تمامی قفل دسترسی‌ها
	\LTRfootnote{lock.}
	 یا منابع دیگر در متدی که صریحاً در برنامه فرا‌خوانی می‌شود. این مورد تا زمانی به درستی کار می‌کند که تمامی کاربران استفاده کننده از کلاس اسم متد را بدانند و به یاد داشته باشند که این متد را زمانی که شئ، دیگر به منابع نیاز نداشت فرا‌خوانی کنند.
	 
	 برخی از دیگر جنبه‌های جذاب اشیاء و کلاس‌های جاوا، متد‌های  
	 \lrInlineMono{main}
	 که برای شروع اجرای برنامه استفاده می‌شود، متد‌های 
	 \lrInlineMono{toString}
	 که برای تولید یک نمایش چاپی از شئ به کار می‌رود، و امکان تعریف متد‌های بومی است:
	 
	\begin{itemize}
		\renewcommand{\labelitemi}{\color{gray}\scriptsize$\blacksquare$}
		\item 
		\texttt{main}
		: ک برنامه جاوا از کلاسی فراخوانی می‌شود که اسم آن از اسم برنامه مشتق گرفته شده است. این کلاس باید یک متد 
		\lrInlineMono{main}
		داشته باشد که باید دسترسی‌
		\lrInlineMono{public} 
		و در نوع 
		\lrInlineMono{static}\footnote{ایستا.}
		باشد و نوع 
		\lrInlineMono{void}\footnote{پوچ.}
		را برگرداند. همچنین یک تک آرگومان از نوع 
		\lrInlineMono{String[]}
		نیز دریافت کند.  متد 
		\lrInlineMono{main}
		در یک آرایه رشته به همراه برنامه فراخوانی شده است.  هر کلاسی با یک متد 
		\lrInlineMono{main}
		می‌تواند به صورت مستقیم فراخوانی شود مثل اینکه یک برنامه مستقل است، که می‌تواند برای امتحان مناسب باشد.
		
		\item\texttt{toString} : 
		یک کلاس ممکن یک متد 
		\lrInlineMono{toString}
		تعریف کند، و زمانی فراخوانی می‌شود که یک تبدیل نوع به رشته نیاز باش، مانند چاپ یک شئ.
	  	
	  	\item\textit{
	  	متد‌های بومی} : یک متد بومی، متدی است که در زبان دیگر نوشته می‌شود، مانند 
  		\lrInlineMono{C}
  		با استفاده از متد‌های بومی قابلیت حمل و امنیت برنامه کاهش پیدا می‌کند. کدهای بومی را نمی‌توان بر حسب تقاضا بر روی شبکه منتقل کرد، و کنترل‌های موجود در 
  		\lr{JVM}
  		به دلیل تفسیر نشدن کد با ماشین مجازی، بی‌اثر هستند. دلایم استفاده از کد‌های بومی (۱) کارایی کد شئ یومی و (۲) دسترسی به کد و برنامه‌هایی که در حال حاظر در زبان دیگر نوشته شده‌اند، هستند.
  		
	\end{itemize}
	 
	\subsection{
	بسته‌ها و رؤیت}
	\label{subsec2:sec2:chap13}

جاوا چهار رؤیت متفاوت برای فیلدها و متدها دارد، که سه مورد آنها مربوط به سطوح رؤیت در 
	\lr{C++}
	و چهارمین آن ناشی از وجود بسته‌ها است.
	
	%Figure 13.1 Java package and	class visibility.
	
	بسته‌های جاوا کپسوله سازی مشابه با فضای نام 
	\LTRfootnote{\lr{namespaces.}}
	\lr{C++}
	دارند که اجازه می‌دهند، اعلان‌های مرتبط با برخی اعلان‌های دیگر یک دسته شوند و از بسته‌های دیگر مخفی باشند. 
در یک برنامه جاوا، هر فیلد و متد متعلق به یک کلاس خاص است و هر کلاس بخشی از یک بسته است، همانطور که در 
	\hyperref[fig1:subsec2:sec2:chap13]{
	شکل ۱۳.۱} آمده است، یک کلاس می‌تواند متعلق به یک بسته بی‌نام پیش فرض،‌ یا برخی از بسته‌های دیگر که در فایلی که شامل کلاس است مشخص شده‌اند، باشد.

	تمایزات رؤیت
	\LTRfootnote{visibility.}
	 در جاوا حالت‌های زیر هستند:
\begin{itemize}[nosep]
	\renewcommand{\labelitemi}{\color{gray}\scriptsize$\blacksquare$}
	\item
	\textit{
	عمومی
	\LTRfootnote{public.}
}: قابل دسترس در همه‌جا و کلاس قابل رؤیت است.
	\item\textit{
	محافظت شده
	\LTRfootnote{protected.}
}: قابل دسترس در متد‌های کلاس و هر زیر کلاسی، و همچنین به کلاس‌های دیگر در بسته یکسان. 
	\item\textit{
	خصوصی
	\LTRfootnote{private.}
}: قابل دسترس فقط در خود کلاس.
	\item\textit{
		بسته
	\LTRfootnote{package.}	
}: فابل دسترس فقط در کد با بسته یکسان، و در زیرکلاس‌های بسته‌های دیگر قابل رؤیت نیست. اعضایی که با یک مشخصه دسترسی خاصی اعلان نشده‌اند، فقط دسترسی بسته را دارند.
\end{itemize}

	به عبارت دیگر، یک متد می‌تواند به عضوی از کلاسی که به آن تعلق دارد، به اعضای غیر خصوصی همه کلاس‌ها در یک بسته، اعضای محافظت شده از کلاس‌های پدر (شامل کلاس‌های پدر در بسته‌های دیگر)، و همچنین اعضای عمومی همه کلاس‌ها در هر بسته قابل رؤیتی، مراجعه کند.
	
	نام‌های که در بسته‌های دیگر اعلان شده‌اند می‌توانند به وسیله 
	\lrInlineMono{import}
	قابل دسترس باشند، که اعلان‌های دیگر بسته‌ها را وارد می‌کند، یا اسامی واجد شرایط که در حالت زیر هستند، که  نشان می‌دهد، بسته صریحا شامل اسم است:  


\begin{latin}
	\color{steelBlue}
	$\underbrace{\texttt{java.lang}}_{\text{package}}.
	\underbrace{\texttt{String}}_{\text{class}}.
	\underbrace{\texttt{substring()}}_{\text{method}}$
\end{latin}

\subsection{
	ارث‌بری}
\label{subsec3:sec2:chap13}
	در واژه‌شناسی، یک زیر کلاس از کلاس پدر خود ارث‌بری می‌کند. که مکانیسم ارث‌بری جاوا ذاتاً مشابه ارث برای در 
	\lr{Smalltalk}، \lr{C++}
	، دیگر زبان‌های برپایه کلاس و شئ کرا است. که نحو نگارش آن در ارث‌بری مشابه 
	\lr{C++}
	، اما با کلیدواژه 
	\lrInlineMono{extends}
	است. همانطور که در این مثال نشان داده‌شده است، کلاس 
	\lrInlineMono{ColorPoint}
	از کلاس 
	\lrInlineMono{Point}
	در 
	\hyperref[subsec1:sec2:chap13]{
	زیربخش ۱۳.۲.۱} گسترش یافته است:

\begin{latin}
	\small
	\begin{lstlisting}[]
class ColorPoint extends Point {
	// Additional fields and methods
	private Color c;
	protected void setC (Color d) {c = d;}
	public Color getC() {return c;}
	// Define constructor
	ColorPoint(int xval, Color cval) {
		super(xval); // call Point constructor
		c = cval; 
	} // initialize ColorPoint field
};
		\end{lstlisting}
\end{latin}	

	\textit{\textbf{
		برجسته‌سازی متد
		\footnote{
			برتر سازی متد
			\lr{overriding}.}
		 و پنهان سازی فیلد‌ها.}}
	همانطور که در زبان‌های دیگر، یک کلاس تمامی فیلد‌های کلاس پدر  خود را به ارث می‌برد، بجز زمانی‌که یک فیلد یا 
	متد‌ به همان نام در زیر کلاس مورد نظر اعلان شده باشد. زمانی که یک متد در کلاس فرزند با یک متد در کلاس پدر هم نام باشد، زیرکلاس آن متد را با همان امضاء برجسته می‌کند. در یک برجسته‌سازی نوع بازگشتی متد نباید با متدی که برجسته
	\LTRfootnote{override /əʊvəˈrʌɪd/.}
	 می‌شود، با برگشت دادن نوع داده دیگر تداخل داشته باشد. یک متد برجسته شده می‌تواند به وسیله کلمه کلیدی
	 \lrInlineMono{super}
	قابل دسترس باشد. برای فیلد‌ها، یک اعلان فیلد در کلاس فرزند با اسم مشابه، تمامی فیلد‌های کلاس پدر با همان نام را پنهان می‌کند. 
	یک فیلد می‌تواند با یک نام توصیف شده  (اگر نوع آن ایستا باشد) یا با استفاده از یک عبارت دسترسی به فیلد که شامل یک تبدیل 
	به نوع کلاس پدر است و یا یا استفاده از کلیدواژه
		\lrInlineMono{super}
		 قابل دسترس باشد.

		\textit{\textbf{
			سازنده‌ها.}} جاوا ضمانت می‌کند، زمانی که یک شئ ایجاد شود سازنده آن نیز فراخوانی می‌شود. در کامپایل شدن سازنده زیرکلاس، کامپایلر چک می‌کند که حتماً سازنده کلاس پدر نیز فراخوانی شود. که اینکار به روشی خاصی که عموماً برنامه‌نویسان درنظر دارند، انجام می‌شود. بخصوص زمانی که در خط ابتدایی یک سازنده فراخوانی سازنده کلاس پدر انجام نشده است، در نتیجه کامپایلر فراخوانی تابع 
		\lrInlineMono{super()}
		را در خط اول اضافه می‌کند. البته این حالت همیشه درست عمل نمی‌کند، زیرا اگر کلاس پدر سازنده‌ای با هیچ آرگومانی
		\footnote{
		متغیره‌هایی که در ورودی تابع تعبیه می‌شوند تا بتوان به هنگام فراخونی مقادیر را به تابع فرستاد.}
	وجود نداشته باشد. فراخوانی متد 
	\lrInlineMono{super()}
	با سازنده‌های اعلان شده همخوانی نخواهد داشت، و در نتیجه باعث خطای زمان کامپایل می‌شود.
	یک استثناء در این مورد زمانی است که یک سازنده سازنده دیگری را فراخوانی کند. در این حالت سازنده اول نیازی به فراخوانی سازنده کلاس پدر را ندارد، اما سازنده دوم باید این کار را انجام دهد.
	برای مثال، اگر چنین سازنده کلاسی 
	\lrInlineMono{ColorPoint() \{ ColorPoint(0,blue);\}} 
	به کلاس 
	\lrInlineMono{ColorPoint}
	که قبلاً معرفی شد اضافه شود. در نتیجه این سازنده بدون اضافه کردن فراخوانی از سازنده کلاس پدر کامپایل می‌شود. یک اعجاب جزئی جاوا متفاوت بودن رفتار‌های ارث بری در دو متد 
	\lr{finilize}\footnote{نهایی سازی}
	و سازنده است، که کامپایلر هیچ اجباری برای فراخوانی متد 
	\lr{finilize}
	کلاس پدر در متد 
	\lr{finilize}
	زیرکلاس وجود ندارد.
	 
	
	
\lr{
	 This does not always work well, because, if the superclass does
	not have a constructor with no arguments, the call super() will not match a declared
	constructor, and a compiler error results. An exception to this check occurs if one con-
	structor invokes another. In this case, the first constructor does not need to call the su-
	perclass constructor, but the second one must. For example, 
	if the constructor declara-
	tion ColorPoint() { ColorPoint(0,blue);} is added to the preceding ColorPoint class, then
	this constructor is compiled without inserting a call to the superclass Point constructor.
	
	A slight oddity of Java is that the inheritance conventions for finalize are different
	from the conventions for constructors. Although a call to the superclass is required
	for constructors, the compiler does not force a call to the superclass finalize method
}
	
	
    Final Methods and Classes. Java contains an interesting mechanism for restricting
	subclasses of a class: A method or an entire class can be declared final. If a method
	is declared final, then the method cannot be overridden in any subclass. If a class is
	declared final, then the class cannot have any subclasses. The reason for this feature
	is that a programmer may wish to define the behavior of all objects of a certain type.
	Because subclasses produce subtypes, as discussed in Section 13.3, this requires some
	restriction on subclasses. To give an extreme example, the singleton pattern discussed
	in Section 10.4 shows how to design a class so that only one object of the class can
	394 Portability and Safety: Java
	be created. The pattern hides the constructor of the class and makes public only a
	function that will call the constructor once during program execution. This pattern
	solves the problem of restricting the number of objects of the class, but only if no
	subclass overrides the public method with a method that can create more than one
	object. If a programmer really wants to enforce the singleton pattern, there must be
	a way to keep other programmers from defining subclasses of the singleton class.
	The Java class java.lang.System is another example of a final class. This class is
	final so that programmers do not override system methods.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

\end{document}